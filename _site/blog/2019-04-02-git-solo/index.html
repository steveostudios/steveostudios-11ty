<article><p>99% of articles and tutorials about Git will tell you that Git is super important because it helps you with collaboration. Features and bug fixes can be broken out into <em>branches</em>. Other developers can pick or be assigned issues to work on. And, when their work is done, it can be <em>merged</em> back into some <em>master</em> code-base.</p>
<p>Where I work we have a pretty small development team.Â :cough:. Well, it's just me right now. Me, a second-career, self-taught, remote developer. I dream of the day that we have more developers. The idea of assigning a bug to another developer sounds about as great as eating a strawberry cupcake on a unicorn prancing over a rainbow! But, low, there is nobody else here. So why would I <em>need to</em> go through all of the trouble of using Git! I have no-one <em>collaborate with</em>, and if Git is only good for collaboration, then it's kinda worthless.</p>
<p>Or so I thought.</p>
<p>It turns out that Git is <em>much more than collaboration</em>! As a solo, Git is great at keeping version history and keeping track of progress.</p>
<p>Only recently have I started to pick up this superpower. It took a bit of a mental shift to get here. Git is really difficult to understand. While the benefits of Git are incredible, the headaches that Git can cause can be detrimental! If you mess something up you can lose weeks worth of work. But, I think I finally have a methodology that works. In this post I want to share a few tips that I have picked up along the way that may help when it comes to using Git as a solo-developer.</p>
<h2>Use an &quot;issueÂ tracker&quot;</h2>
<p>I'll go into my process in a different post, but I think this was key for meâ€Š-â€Šuse an issue tracker as your todo list. Personally I use <a href="http://gitlab.com/" title="Gitlab">Gitlab</a> (since that is where I host my projects) but you can use <a href="http://github.com/" title="Github">Github</a>, <a href="http://bitbucket.com/" title="Bit Bucket">BitBucket</a>, <a href="http://asana.com/" title="Asana">Asana</a>, <a href="http://wunderlist.com/" title="Wunderlist">Wunderlist</a> (RIP), a leather-bound Moleskin (hipsters represent), or whatever. The idea is to write down every feature or bug that needs to get fixed, no matter the size or time it will take to solve the problem.</p>
<h2>Every Issue gets a unique issueÂ number</h2>
<p>I find it useful to have a unique issue number associated with the issue. The main reason is that you can refer to a feature or bug later by it's ID. If you're using GitLab or Github then you can reference this ID directly in comments and commits. But one of my favorite things is that if you use the issue number to prefix your branch name, these tools really shine. You can check off issues, reference others, and do other crazy voodoo, all because your issues have a unique number!</p>
<h2>Work with smaller features/bugs</h2>
<p>Another key is to separate the key problems that your solving into smaller parts and turn those into issues. A feature like &quot;Redesign UI&quot; is way too large of a task. Instead, break it down into &quot;Top-nav layout&quot;, &quot;Update button colors&quot;, and &quot;Add this month's trendy image slider&quot;. This helps in several ways:</p>
<ol>
<li>It helps you think through and start to solve tasks <em>before</em> you get to coding. Simpler problems = less cognitive overload = you to move faster = ðŸ¤“.</li>
<li>It helps fight against scope-creep. Since that feature has already been defined, new ideas need to go somewhere else. Later you may think, &quot;Oh, I should also add a testimonial section to the homepage.&quot; Greatâ€¦ that is a <em>new issue</em>. Don't even think about adding that to an existing feature.</li>
<li>Smaller features means you to check off issues rapidly, giving you a boost of confidence. There is nothing more disparaging than being 2 weeks into a massive feature, drowning in loneliness. Checking off issues makes you feel like you can conquer the next one. âœ”âœ”âœ”âœ”âœ”</li>
<li>Seeing all of the little steps helps more accurately scope timelines. If you know each of the four tasks will take 30 minutes, you can assume your timeline is 2 hours, give or take. Quoting time on a larger task is like a carnival gameâ€Š-â€Šyou might win the teddy bear, or you might shoot your eye out.</li>
</ol>
<h2>Commit frequently</h2>
<p>Don't be afraid of <em>commit</em>-ment. I use to feel like I had to be happy or done with a piece of code in order to commit it. Now I realize that this is more power in committing frequently. If you're going down a path that you realize is totally wrong, you can go back in time to <em>before</em> that mistake. And, since I can't tell when future-me is going to want to go back in time, I commit frequently.</p>
<h2>Set up someÂ aliases</h2>
<p>Since Git is a command-line tool and I am terrible at typing, I let the computer help me out. I have my terminal setup using <a href="https://github.com/robbyrussell/oh-my-zsh" title="Oh My ZSH">Oh-My-ZSH</a>, which includes some handy aliases. Here are some of my favorites:</p>
<table>
<thead>
<tr>
<th>Alias</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>gaa</em></td>
<td>git add --all</td>
</tr>
<tr>
<td><em>gc</em></td>
<td>git commit -v</td>
</tr>
<tr>
<td><em>gp</em></td>
<td>git push</td>
</tr>
<tr>
<td><em>gl</em></td>
<td>git pull</td>
</tr>
<tr>
<td><em>gcb</em></td>
<td>git checkout -b</td>
</tr>
<tr>
<td><em>gcd</em></td>
<td>git checkout develop</td>
</tr>
<tr>
<td><em>gpsup</em></td>
<td>git push --set-upstream origin $(current_branch)</td>
</tr>
</tbody>
</table>
<h2>Use VSÂ Code</h2>
<p><a href="https://code.visualstudio.com/" title="Microsoft VS Code">Microsoft VS Code</a> has a ton of tools that help when it comes to developing with Git. Being a visual learner, and a novice at best when it comes to Git, VS Code gives me the confidence to push commit.</p>
<p>First, if you're current project has a repo in it, it will automatically keep track of all the changed that need staged. There is even a whole panel devoted to it! This helps because I can always see what I've changed, and it reminds me to commitâ€Š-â€ŠI don't want this list to get too long! You commit right here, too! I find this easier to understand and less error prone than using the command-line. I can see exactly which files are staged, write out my message, and I don't have to remember to <code>-m</code> my message orÂ <code>:wq</code> to exit Vim (or is itÂ <code>:qw</code>?).</p>
<p><img src="./vs-code-commit.jpg" alt="VS Code Git Panel"></p>
<p>There are also a few plugins that really make VS Code shine. I use:</p>
<ul>
<li><strong><a href="https://marketplace.visualstudio.com/items?itemName=donjayamanne.githistory" title="Git History">Git History</a></strong>: I use it to see diffs in my code (I swear I have zero short term memory).</li>
<li><strong><a href="https://marketplace.visualstudio.com/items?itemName=fatihacet.gitlab-workflow" title="Gitlab Workflow">GitLab Workflow</a></strong>: I use this to to create merge requests.</li>
</ul>
<p>Not having to leave my code editor helps me stay in the zone, commit quickly, and then get to the next commit. Bing, bang, boop!</p>
<hr>
<p>I'll go over my particular workflow in another post, and show you specifically how I use Git not only as my code repository, but also my task list. Stay tuned!</p>
</article>